module Zwana where

import fregefx.JavaFxType 
import fregefx.JavaFxAll hiding (Rectangle)
import fregefx.JavaFxUtils

import Prelude.Math

-- fregeFX classes

-- reimplement Rectangle to add listeners
data Rectangle = mutable native javafx.scene.shape.Rectangle where
    native setOnMouseClicked :: Rectangle -> EventHandler MouseEvent -> JFX ()

data MouseEvent = native javafx.scene.input.MouseEvent

instance CastTarget Rectangle where
    native downcast "(javafx.scene.shape.Rectangle)" :: Node -> JFX (ClassCastException | Rectangle )

instance CastTarget TextField where
    native downcast "(javafx.scene.control.TextField)" :: Node -> JFX (ClassCastException | TextField )

instance CastTarget Slider where
    native downcast "(javafx.scene.control.Slider)" :: Node -> JFX (ClassCastException | Slider )

data TextField = mutable native javafx.scene.control.TextField where
    native getText :: TextField -> IO String
    native setOnAction :: TextField -> EventHandler ActionEvent -> JFX ()

data Slider = mutable native javafx.scene.control.Slider where
    native getValue :: Slider -> IO Double
    native increment :: Slider -> JFX ()

-- java sound classes
data MidiSystem = native javax.sound.midi.MidiSystem where 
    native getSequencer "javax.sound.midi.MidiSystem.getSequencer" :: () -> STMutable s Sequencer throws MidiUnavailableException
    native getSynthesizer "javax.sound.midi.MidiSystem.getSynthesizer" :: () -> STMutable s Synthesizer throws MidiUnavailableException

data InvalidMidiDataException = native javax.sound.midi.InvalidMidiDataException
derive Exceptional InvalidMidiDataException

data MidiEvent = native javax.sound.midi.MidiEvent where
    native new :: Mutable s ShortMessage -> Int -> STMutable s MidiEvent

data Instrument = pure native javax.sound.midi.Instrument
derive ArrayElement Instrument

data Soundbank = native javax.sound.midi.Soundbank where
    native getInstruments  :: Mutable s Soundbank -> STMutable s (JArray Instrument)

data MidiChannel = pure native javax.sound.midi.MidiChannel where
    native noteOn :: MidiChannel -> Int -> Int -> IO ()
    native noteOff :: MidiChannel -> Int -> IO ()

derive ArrayElement MidiChannel

data Synthesizer = native javax.sound.midi.Synthesizer where
    native open :: MutableIO Synthesizer -> IO () throws MidiUnavailableException
    native getChannels :: Mutable s Synthesizer -> STMutable s (JArray MidiChannel)
    native getDefaultSoundbank :: Mutable s Synthesizer -> STMutable s Soundbank
    native loadInstrument :: Mutable s Synthesizer -> Instrument -> ST s Bool

data MidiUnavailableException = native javax.sound.midi.MidiUnavailableException
derive Exceptional MidiUnavailableException

-- utility functions

toInt :: String -> Int
toInt x = either (const 0) id x.int

truncate :: Double -> Int
truncate n = let n' = round n
             in if ( n'.double > n ) then (n' - 1).int else (n').int

-- main and GUI

main :: IO ()
main = do
    FregeFX.launch $ withStage buildUI


buildUI :: Family a => a -> Stage -> JFX a
buildUI root stage = do
    stage.setTitle "Zwana"
    content <- FregeFX.fxml "Zwana" "/Zwana.fxml"
    scene <- Scene.new content 490.0 318.0
    i <- lookupNode scene "#inputInstrument" :: JFX TextField
    o <- lookupNode scene "#sliderOctave" :: JFX Slider
    onKeyPressed scene i o
    let keys = zip [0..] (map (\x -> lookupNode scene x :: JFX Rectangle) notes)
    forM_ keys (\ (k, note) -> note >>= (\n -> n.setOnMouseClicked (onAction (\ _ -> (playNote (instrument i) (octave o) k) `thenDo` handler) ) ) )
    stage.setScene scene
    stage.setResizable False
    Stage.show stage
    return root

--  dummy functio to take an action from the IO monad to the JFX monad
handler :: () -> JFX ()
handler f = return ()

onKeyPressed :: Scene -> TextField -> Slider -> JFX ()
onKeyPressed scene i o = do
    scene.setOnKeyPressed (onAction (\k -> k.getCode >>= \keyCode -> KeyCode.getName keyCode >>= \ keyName -> (playNote (instrument i) (octave o) (fromKey keyName)) `thenDo` handler))

fromKey :: String -> Int
fromKey s = case s of
    "Z"     -> 0
    "S"     -> 1
    "X"     -> 2
    "D"     -> 3
    "C"     -> 4
    "V"     -> 5
    "G"     -> 6
    "B"     -> 7
    "H"     -> 8
    "N"     -> 9
    "J"     -> 10
    "M"     -> 11
    "Comma" -> 12
    "Q"     -> 12
    "2"     -> 13
    "W"     -> 14
    "3"     -> 15
    "E"     -> 16
    "R"     -> 17
    "5"     -> 18
    "T"     -> 19
    "6"     -> 20
    "Y"     -> 21
    "7"     -> 22
    "U"     -> 23
    "I"     -> 14
    _       -> 0

-- sound functions

type Note = Int

instrument :: TextField -> IO Int
instrument i = liftM toInt i.getText

octave :: Slider -> IO Int
octave o = liftM truncate o.getValue

playNote :: IO Int -> IO Int -> Note -> IO ()
playNote i o n = do
    i' <- i
    o' <- o
    let note = o' * 12 + n
    synthesizer <- MidiSystem.getSynthesizer ()
    synthesizer.open
    soundbank <- synthesizer.getDefaultSoundbank
    instruments <- soundbank.getInstruments
    channels <- synthesizer.getChannels
    firstChannel <- getElemAt channels 0
    instr <- getElemAt instruments i'
    _ <- synthesizer.loadInstrument instr
    firstChannel.noteOn note 100
    Thread.sleep 1000
    firstChannel.noteOff note
    return ()

notes :: [String]
notes = ["#keyC","#keyCSharp","#keyD","#keyDSharp","#keyE","#keyF","#keyFSharp","#keyG","#keyGSharp","#keyA","#keyASharp","#keyB", "#keyCUp"]
