module Zwana where

import frege.Prelude hiding(ListView)
import fregefx.JavaFxType 
import fregefx.JavaFxAll hiding (Rectangle)
import fregefx.JavaFxUtils

import Prelude.Math

-- fregeFX classes

-- reimplement Rectangle to add listeners
data Rectangle = mutable native javafx.scene.shape.Rectangle where
    native setOnMouseClicked :: Rectangle -> EventHandler MouseEvent -> JFX ()

data MouseEvent = native javafx.scene.input.MouseEvent

instance CastTarget Rectangle where
    native downcast "(javafx.scene.shape.Rectangle)" :: Node -> JFX (ClassCastException | Rectangle )

instance CastTarget TextField where
    native downcast "(javafx.scene.control.TextField)" :: Node -> JFX (ClassCastException | TextField )

instance CastTarget Slider where
    native downcast "(javafx.scene.control.Slider)" :: Node -> JFX (ClassCastException | Slider )

data TextField = mutable native javafx.scene.control.TextField where
    native getText :: TextField -> IO String
    native setOnAction :: TextField -> EventHandler ActionEvent -> JFX ()

data Slider = mutable native javafx.scene.control.Slider where
    native getValue :: Slider -> IO Double
    native increment :: Slider -> JFX ()

-- java sound classes
data MidiSystem = native javax.sound.midi.MidiSystem where 
    native getSequencer "javax.sound.midi.MidiSystem.getSequencer" :: () -> STMutable s Sequencer throws MidiUnavailableException

data Sequence = native javax.sound.midi.Sequence where
    native new :: Float -> Int -> STMutable s Sequence throws InvalidMidiDataException
    native createTrack :: Mutable s Sequence -> STMutable s Track
    pure native ppq "javax.sound.midi.Sequence.PPQ" :: Float

data InvalidMidiDataException = native javax.sound.midi.InvalidMidiDataException
derive Exceptional InvalidMidiDataException

data MidiEvent = native javax.sound.midi.MidiEvent where
    native new :: Mutable s ShortMessage -> Int -> STMutable s MidiEvent

data ShortMessage = native javax.sound.midi.ShortMessage where
    native new :: Int -> Int -> Int -> Int -> STMutable s ShortMessage throws InvalidMidiDataException


data Track = native javax.sound.midi.Track where
    native add :: Mutable s Track -> Mutable s MidiEvent -> ST s Bool
    native remove :: Mutable s Track -> Mutable s MidiEvent -> ST s Bool


data Sequencer = native javax.sound.midi.Sequencer where
    native open :: MutableIO Sequencer -> IO () throws MidiUnavailableException
    native close :: MutableIO Sequencer -> IO ()
    native start :: MutableIO Sequencer -> IO ()
    native setSequence :: MutableIO Sequencer -> MutableIO Sequence -> IO () throws InvalidMidiDataException

data MidiUnavailableException = native javax.sound.midi.MidiUnavailableException
derive Exceptional MidiUnavailableException

-- utility functions

toInt :: String -> Int
toInt x = either (const 0) id x.int

truncate :: Double -> Int
truncate n = let n' = round n
             in if ( n'.double > n ) then (n' - 1).int else (n').int

-- main and GUI

main :: IO ()
main = do
    FregeFX.launch $ withStage buildUI


buildUI :: Family a => a -> Stage -> JFX a
buildUI root stage = do
    stage.setTitle "Zwana"
    content <- FregeFX.fxml "Zwana" "/Zwana.fxml"
    scene <- Scene.new content 490.0 318.0
    instrument <- lookupNode scene "#inputInstrument" :: JFX TextField
    octave <- lookupNode scene "#sliderOctave" :: JFX Slider
    onKeyPressed scene instrument octave
    let keys = zip [0..] (map (\x -> lookupNode scene x :: JFX Rectangle) notes)
    forM_ keys (\ (k, note) -> note >>= (\n -> n.setOnMouseClicked (onAction (\ _ -> (playNote instrument octave k) `thenDo` handler))))
    stage.setScene scene
    stage.setResizable False
    Stage.show stage
    return root

--  dummy functio to take an action from the IO monad to the JFX monad
handler :: () -> JFX ()
handler f = return ()

onKeyPressed :: Scene -> TextField -> Slider -> JFX ()
onKeyPressed scene instrument octave = do
    scene.setOnKeyPressed (onAction (\k -> k.getCode >>= \keyCode -> KeyCode.getName keyCode >>= \ keyName -> (playNote instrument octave (fromKey keyName)) `thenDo` handler))

handleKeyEvent :: KeyEvent -> JFX ()
handleKeyEvent k = do
    keyCode <- k.getCode
    keyName <- KeyCode.getName keyCode
    let note = fromKey keyName
    (println note) `thenDo` handler

fromKey :: String -> Int
fromKey s = case s of
    "Z"     -> 0
    "S"     -> 1
    "X"     -> 2
    "D"     -> 3
    "C"     -> 4
    "V"     -> 5
    "G"     -> 6
    "B"     -> 7
    "H"     -> 8
    "N"     -> 9
    "J"     -> 10
    "M"     -> 11
    "Comma" -> 12
    _       -> 0

-- sound functions

type Note = Int

playNote :: TextField -> Slider -> Note -> IO ()
playNote i o n = do
    instrument <- liftM toInt i.getText
    octave <- liftM truncate o.getValue
    let note = octave * 12 + n
    sequencer <- MidiSystem.getSequencer ()
    sequencer.open
    sequence <- Sequence.new Sequence.ppq 4
    track <- sequence.createTrack

    changeInstrument <- ShortMessage.new 192 1 instrument 0
    changeInstrument' <- MidiEvent.new changeInstrument 1
    track.add changeInstrument'

    noteOn <- ShortMessage.new 144 1 note 100
    noteOn' <- MidiEvent.new noteOn 1
    track.add noteOn'

    noteOff <- ShortMessage.new 128 1 note 100
    noteOff' <- MidiEvent.new noteOff 16
    track.add noteOff'

    sequencer.setSequence sequence
    sequencer.start
    return ()

notes :: [String]
notes = ["#keyC","#keyCSharp","#keyD","#keyDSharp","#keyE","#keyF","#keyFSharp","#keyG","#keyGSharp","#keyA","#keyASharp","#keyB", "#keyCUp"]
